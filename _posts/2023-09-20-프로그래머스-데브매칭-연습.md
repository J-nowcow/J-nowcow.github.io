---
title: 프로그래머스 데브매칭 연습
author: cotes
date: 2023-09-20 11:10:00 +0900
render_with_liquid: false
---

9월 10일에 프로그래머스 데브매칭을 위한 PCCP 특별시험이 있었습니다.
데브매칭에는 프론트랑 백엔드만 있어서 지원할 생각은 없었지만, 소마에서 지원한 팀원들이 있어서 풀이 공유 목적으로 신청했습니다.

데브매칭 준비를 위해 백준에서 적당히 코딩테스트에 나올 만한 문제를 뽑아서 같이 풀었습니다.

원래 c++로 하지만 다른 팀원들이 대부분 파이썬으로 풀어서 공유를 위해 전부 파이썬으로 해결했습니다.

문제 목록은 다음과 같습니다.
![image](https://github.com/J-nowcow/J-nowcow.github.io/assets/61009093/d7b1fb43-574b-4f2e-8619-43e35b0d87f1)

{% include boj-problem.html problem_list="10431, 1205, 1515, 1476, 2644, 2477, 2503, 11722, 14916, 2629, 16395, 1328, 1977, 2210, 10819, 11170, 10159, 1388, 1052" %}

### BOJ 10431 줄세우기

[문제 링크](https://www.acmicpc.net/problem/10431)

> 20명의 학생의 키가 순서대로 주어지고 각 학생은 `자기보다 앞에 있는 사람의 바로 앞 자리` 에 선다고 할 때, 뒤로 물러서는 횟수 구하기

삽입정렬을 할 때 swap이 일어나는 수를 세면 됩니다.
버블로 돌려도 총 개수는 동일해서 버블 정렬로 구했습니다.

[정답 코드](http://boj.kr/66193c8bafc74984a6ab806ca07ddec4)


### BOJ 1205 등수 구하기

[문제 링크](https://www.acmicpc.net/problem/1205)

> `P`개의 점수를 보여주는 점수판에 현재 `N`개의 점수가 올라와 있을 때, 다음에 들어오는 점수는 점수판의 몇 번째 순위로 들어가는지 구하기 
 
점수판에 아예 올라가지 못하는 경우를 주의해서 구현해주면 됩니다.

[정답 코드](http://boj.kr/29db10f8a56a4581b54d11a1f344d650)

### BOJ 1515 수 이어 쓰기

[문제 링크](https://www.acmicpc.net/problem/1515)

> `1`부터 `N`까지 이어붙인 수에서 일부를 지운 결과가 주어졌을 때, 가능한 `N`의 최솟값 구하기 ($N\leq 3,000$)

1부터 시작해서, 주어진 문자열의 가장 앞자리부터 숫자가 겹치는지 확인합니다. 만약 겹친다면 문자열의 다음 자리로 넘어갑니다. 
현재 숫자와 겹치는데 지우지 않는 것이 최선인 상황이 있다고 가정하면, 다음과 같은 상황을 생각해볼 수 있습니다.
현재 확인할 문자열이 `47` 이고, 보고 있는 숫자가 `46` 이라고 합시다. 만약 여기서 4를 지우지 않는다면, 다음 숫자인 `47`에서 문자열을 모두 지울 수 있습니다. 하지만 `4`를 지워도 다음 숫자인 47의 `7`에서 남은 문자열을 지울 수 있습니다. 따라서 그리디하게 항상 현재 숫자와 겹치는 문자열을 지우는 것이 최선입니다.

[정답 코드](http://boj.kr/29b2d4495cb54d8592e32b0cd3ae0896)

### BOJ 1476 날짜 계산

[문제 링크](https://www.acmicpc.net/problem/1476)

> E, S, M이 주어졌을 때, 가장 빠르게 E, S, M이 동시에 주어진 년도가 되는 년도 구하기

$15x + e = 28y + s = 19z + m = k$ 를 만족하는 `k`의 최솟값을 구해주면 됩니다.

[정답 코드](http://boj.kr/a4e73346d66b4e2e9dc015fc108a2416)

### BOJ 2644 촌수 계산

[문제 링크](https://www.acmicpc.net/problem/2644)

> 부모-자식 관계가 주어졌을 때, 주어진 두 사람의 촌수 구하기

그래프의 두 노드 간의 최단 거리를 구하는 문제입니다. BFS를 이용해서 풀 수 있습니다.

[정답 코드](http://boj.kr/c0eb9cf2ba2247dfb0b2704b27178819)

### BOJ 2477 참외밭

[문제 링크](https://www.acmicpc.net/problem/2477)

> 직사각형에서 일부가 파인 모양의 밭이 주여졌을 때 참외의 개수 구하기

참외밭의 넓이만 구하면 참외의 개수는 바로 알 수 있습니다. 방법은 여러 가지가 있지만 저는 중앙점의 위치와 잘린 부분의 방향을 구한 다음 `큰 직사각형` - `잘린 직사각형`을 구했습니다.

[정답 코드](http://boj.kr/87964f11c3ee43e3be7741c2319aaf86)

### BOJ 2503 숫자 야구

[문제 링크](https://www.acmicpc.net/problem/2503)

> 숫자 3개로 하는 숫자 야구

각 입력값에 대해 불가능한 숫자를 제외하는 것보다, 123부터 987까지 모든 숫자를 돌면서 주어진 모든 조건을 만족하는지 체크하는게 구현하기 더 쉬운 것 같습니다.

[정답 코드](https://www.acmicpc.net/source/share/c675871c4885410db06ddd9f9db7cc64)

### BOJ 11722 가장 긴 감소하는 부분 수열

[문제 링크](https://www.acmicpc.net/problem/11722)

> LIS (longest increasing subsequence) 연습문제

LIS는 $O(nlogn)$ 풀이가 존재하지만 여기서는 $O(n^2)$으로도 돌아갑니다.
`dp[i] = i번 째 원소를 포함하는 가장 긴 감소하는 부분 수열의 길이` 라고 정의하면, `dp[i] = max(dp[j] + 1) (j < i, a[j] > a[i])` 로 구할 수 있습니다.

[정답 코드](https://www.acmicpc.net/source/share/1aa12f5c658b4578a70d8b222fbec2b7)

### BOJ 14916 거스름돈

[문제 링크](https://www.acmicpc.net/problem/14916)

> 5원짜리와 2원짜리로 n원을 거슬러 줄 때, 필요한 동전의 최소 개수 구하기

`n = 1, 3`을 제외하고 전부 만들 수 있습니다.
참고로 두 수 `a`, `b`가 주어졌을 때 `lcm(a, b) - a - b`원보다 큰 거스름돈은 항상 만들 수 있습니다. (* lcm : 최소공배수)
가능한 동전의 최소 개수는 10원 이하가 남을 때까지 5원을 최대한 채워넣은 후, 남은 금액에 따라 2원과 5원을 적당히 채워넣으면 됩니다.
한줄로도 짤 수 있습니다. (정답 코드 참고)

[정답 코드](https://www.acmicpc.net/source/share/123723f047c9477d98761a872520a147)

### BOJ 2629 양팔저울

[문제 링크](https://www.acmicpc.net/problem/2629)

> 주어진 추를 활용하여 양팔저울로 측정할 수 있는 물체의 무게를 구하는 문제 <br>추의 무게 $W \leq 500$, 추의 개수 $N \leq 30$

각 추에 대해 사용하지 않기 / 물건과 같은 방향에 놓기 / 반대 방향에 놓기 3가지 중 하나를 선택할 수 있습니다.
이때 추의 무게가 `a`라면 저울에 가해지는 무게는 `0, a, -a` 중 하나입니다.
측정 가능한 최대 무게는 `15000`이므로, `-15000~15000`까지 를 관리하는 dp 배열을 잡습니다.
`dp[i][j] = i번째 추까지 사용했을 때, j무게를 측정할 수 있는지 여부` 라고 정의하면, `dp[i][j] = dp[i-1][j] or dp[i-1][j-a[i]] or dp[i-1][j+a[i]]` 로 구할 수 있습니다.
dp 배열을 30000부터 시작해서 작아지는 방향으로 업데이트하면 2차원 배열 대신 1차원 배열로도 구현할 수 있습니다. 
시간복잡도는 `O(NW)` 입니다.

[정답 코드](https://www.acmicpc.net/source/share/6c613a917bc14e41ba5b2eb730ead8f6)

### BOJ 16395 파스칼의 삼각형

[문제 링크](https://www.acmicpc.net/problem/16395)

> $nCr$ 구하기

문제에서 파스칼의 삼각형의 원소가 이항계수와 같다고 주어져 있습니다.

이항계수는 다음과 같은 점화식을 만족합니다.
$$
\begin{align}
n \geq k \geq 0 \\
{n \choose k} = {n-1 \choose k-1} + {n-1 \choose k}
\end{align}
$$

하지만 값이 작아서
$$
\frac{n!}{k!(n-k)!}
$$
을 직접 구해줘도 됩니다. (정답 코드 참고)

[정답 코드](http://boj.kr/d5f6b7df13aa4b64bd8036599a7cd38f)

### BOJ 1328 고층 빌딩

[문제 링크](https://www.acmicpc.net/problem/1328)

> `1~n` 까지의 높이를 가진 빌딩을 무작위로 배열했을 때, 왼쪽에서 빌딩이 `L`개가 보이고 오른쪽에서 빌딩이 `R`개가 보이는 경우의 수 구하기

코테에 나오기는 어려운 문제지만 플레도 한번 맛봤으면 좋겠다는 마음으로 한문제 넣었다가, 고통받으면서 저혼자 풀었습니다ㅠㅠ

3차원 dp를 사용해서 푼 사람이 많던데 저는 2차원 dp로 구했습니다.
$dp[n][k]$ `= n개의 건물 중 왼쪽에서 봤을 때 k개의 건물이 보이는 경우의 수`라고 정의합니다.
높이가 n인 건물보다 뒤에 있는 건물은 보이지 않으므로, t번째 건물 높이가 n일 때 가능한 경우의 수는 $dp[t-1][k-1] * (n-1)C(k-1) * (n-t)!$ 입니다. <br>* t번째 건물을 제외한 n-1개의 건물 중 k-1개를 뽑는 경우의 수 = $(n-1)C(k-1)$,
앞쪽 건물을 배치하는 경우의 수 = $dp[t-1][k-1]$,
뒤쪽 건물을 배치하는 경우의 수 = $(n-t)!$
$k \leq t \leq n$ 인 t에 대해 dp값을 각각 구해 모두 더해주면 됩니다.

[정답 코드](http://boj.kr/6a43cabdf65f4a1b8fa61eec00753a83)

### BOJ 2210 숫자판 점프
[문제 링크](https://www.acmicpc.net/problem/2210)

> 5x5 판에서 시작점에서 상하좌우로 이동하면서 만들 수 있는 6자리 수의 개수 구하기

dfs나 bfs 돌리면 됩니다. arr[1000000] 만들어서 확인했으면 true로 바꿔줍시다.

[정답 코드](https://www.acmicpc.net/source/66343682)

### BOJ 1388 바닥 장식
[문제 링크](https://www.acmicpc.net/problem/1388)

> 주어진 그림에서 바닥 장식의 개수 구하기

가로줄에서는 가로 선의 개수만, 세로줄에서만 세로 선의 개수만 셀 것입니다.
가로줄을 보면서 `-|` 인 것들, 세로줄을 보면서 `|-`인 것들을 세줍시다. 해당 모양이 한번씩 나올 때마다 새로운 선이 하나씩 추가됨을 알 수 있습니다.

[정답 코드](http://boj.kr/40adf54d7dfa459c9fc6268b4f98ef6b)

### BOJ 1068 트리
[문제 링크](https://www.acmicpc.net/problem/1068)

> 트리에서 노드 하나를 지웠을 때 리프 노드의 개수 구하기

노드 class 만들어서 트리 구성 후 자식 수를 세는데, 만약 자식 노드가 지워진 노드라면 빼고 세는 식으로 구현했습니다.

[정답 코드](http://boj.kr/430a628a579149c89b88c6c01d0811d0)

### BOJ 3184 양
[문제 링크](https://www.acmicpc.net/problem/3184)

> 울타리로 분할된 각 영역에서 양이 많은지 늑대가 많은지 수 세기

BFS/DFS 아무거나 돌려도 됩니다. 

[정답 코드](http://boj.kr/8628795095bb4c3c9af0dbd5cfc9b4d6)

### BOJ 10819 차이를 최대로
[문제 링크](https://www.acmicpc.net/problem/10819)

> 주어진 식의 최대값 계산하기

$N\leq8$ 이므로 브루트포스로 풀 수 있습니다.
재귀로 짜도 되고, itertools를 쓰면 구현이 가벼워집니다.

[정답 코드](http://boj.kr/6821e5bae8f04d858f68c0173b5f6e31)

### BOJ 1977 완전제곱수
[문제 링크](https://www.acmicpc.net/problem/1977)

> $N\leq k \leq M$ 인 완전제곱수 k의 개수 구하기

이 셋에서 몇 안되는 브론즈 문제입니다.
브루트포스로 하나씩 확인해줘도 됩니다.

[정답 코드](http://boj.kr/1a662f3b6b3240f29481c80716715037)

### BOJ 1977 0의 개수
[문제 링크](https://www.acmicpc.net/problem/11170)

> $N\leq k \leq M$ 인 k에 포함된 0의 개수 구하기

1부터 100만까지 전처리한 다음 누적합 구해서 계산했습니다. 그런데 제한이랑 티어 생각하면 그냥 하나씩 브루트포스로 확인하라고 준 문제같네요.

[정답 코드](http://boj.kr/00043a88377a4e7dbbdb71eafb864cd0)
### BOJ 2665 미로만들기
[문제 링크](https://www.acmicpc.net/problem/12665)

> 검은 칸을 최소로 지나고 도착 지점까지 도착하도록 하는 경로에서 지나가는 검은 칸의 개수 구하기

다익스트라 알고리즘 태그중에 하나 뽑은건데 아무리 봐도 왜 다익스트라인지 모르겠습니다.. 이 셋중에 체감상 가장 어렵고 오래 걸렸네요

흰 칸을 관리하는 큐랑 검은 칸을 관리하는 큐를 하나씩 만든 다음 각각 관리했습니다.
흰 칸에 도달하면 그 칸과 연결된 모든 하얀 칸을 도달한 것으로 체크하고, 인접한 검은 칸을 검은 큐에 넣습니다.
검은 칸에 도달하면 맞닿아 있는 칸들만 체크합니다. (검은 칸은 하나 지날때마다 값이 1씩 증가하기 때문에, 맞닿아 있는 칸들만 확인해서 큐에 넣어줘야 BFS의 느낌을 유지할 수 있습니다.)

[정답 코드](http://boj.kr/21043458925943b5a77535b5185dbe50)
### BOJ 10159 저울
[문제 링크](https://www.acmicpc.net/problem/10159)

> 일부 물건 쌍에 대해 어떤 물건이 더 무거운지 주어진 상황에서, 서로 더 무거운 물건을 알 수 없는 쌍의 개수 구하기

각각의 물건을 노드로 생각하고, 어떤 두 물건의 대소관계가 주어진 경우 단방향 간선으로 연결된 것으로 간주합시다. 
$a < b$ 라면 $a \rightarrow b$ 라고 생각하면 됩니다.

플루이드-와셜 알고리즘을 활용하면 $O(n^3)$ 시간에 모든 간선에서 다른 간선으로 갈 수 있는지 확인할 수 있습니다.
간선으로 연결되어 있다면 대소관계를 반드시 알 수 있고, 연결되어 있지 않다면 대소관계를 알 수 없습니다.

[정답 코드](http://boj.kr/a5754cb82483492087154d7a2ee6f943)

### BOJ 1052 물병
[문제 링크](https://www.acmicpc.net/problem/1052)

> 1리터짜리 물병 `N`개를 가지고 있고, 같은 양의 물이 들어 있는 물병 두개를 합칠 수 있을 때 물병의 개수를 `K`개 이하로 줄이려면 최소 몇 개의 1리터짜리 물병을 더 사야하는지 구하기

정답은 항상 존재합니다. (물병을 1개로 만들 수 있으므로)
물병을 하나도 구매하지 않았을 때 만들 수 있는 물병의 최소 개수는 N을 2진수로 변환했을 때 1의 개수와 동일합니다. (물병이 2개 있으면 1 + 1 -> 10 이 된다는 점에서 생각해봅시다)
또한 새로운 물병을 하나 구입할 때마다 방금 만든 2진수에 1씩 더해준다고 생각하면 됩니다.
$2^0$의 자리부터 $2^{31}$ 자리까지 해당 자리수가 1이라면 물병을 2^x개 구매합니다. 그리고 받아올림한 다음 줄어든 물병 수를 계산합니다.
이 방법으로 최대 31번의 계산으로 답을 구할 수 있습니다.


[정답 코드](http://boj.kr/0f3bd9ae8cc64d7c841130223aec217c)

---
## 여담
![image](https://github.com/J-nowcow/J-nowcow.github.io/assets/61009093/66650f29-859c-48e5-aa9e-98060346d793)
주말 아침 10시에 문제풀라고 시켜서 비몽사몽한 상태로 풀었습니다.
2시간 시험인데, 연습을 좀 해서 그런지 구현이 슥슥 돼서 58분 지난 시점에 4문제 전부 예제가 돌아가는 코드가 나왔습니다.
맞았는지를 실시간으로 안가르쳐줘서 좀 쫄렸지만 피곤해서(...) 그냥 내고 나왔는데 다행히 큰 실수는 없었던 것 같네요
돈내고 보면 4만원짜리 인증시험 이라던데 팀원들 덕분에 공짜로 잘 봤습니다 :)